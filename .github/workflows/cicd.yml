name: CICD

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - prd
      deploy_frontend:
        description: 'Deploy frontend'
        required: true
        default: true
        type: boolean
      deploy_backend:
        description: 'Deploy backend'
        required: true
        default: true
        type: boolean

# Cancel in-progress runs for the same PR
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  AWS_REGION: ap-northeast-1

jobs:
  # =============================================================================
  # CI Job - Runs on all triggers
  # =============================================================================
  ci:
    name: CI (Lint, Type Check, Build, Test)
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Cache Bun dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.bun/install/cache
            node_modules
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lock') }}
          restore-keys: |
            ${{ runner.os }}-bun-

      - name: Setup devcontainer compose override
        run: cp .devcontainer/compose.override.yaml.sample .devcontainer/compose.override.yaml

      - name: Run CI in devcontainer
        uses: devcontainers/ci@v0.3
        with:
          imageName: ghcr.io/${{ github.repository }}/devcontainer
          cacheFrom: ghcr.io/${{ github.repository }}/devcontainer
          push: always
          runCmd: |
            bun install --frozen-lockfile
            bun run db:generate
            bun run db:migrate:deploy
            bun run check
            bun run test:run

  # =============================================================================
  # Setup Job - Determines deployment environment and flags
  # Push to main/develop: auto deploy to dev (frontend + backend)
  # Workflow dispatch: use input parameters (main/develop branches only)
  # Branch restrictions:
  #   - workflow_dispatch: main/develop only
  #   - prd deployment: main branch only
  # =============================================================================
  setup:
    name: Setup
    needs: ci
    if: github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ github.event_name == 'push' && 'dev' || inputs.environment }}
      deploy_frontend: ${{ github.event_name == 'push' || inputs.deploy_frontend }}
      deploy_backend: ${{ github.event_name == 'push' || inputs.deploy_backend }}
    steps:
      - name: Validate branch for workflow_dispatch
        if: github.event_name == 'workflow_dispatch'
        run: |
          BRANCH="${{ github.ref_name }}"
          if [[ "$BRANCH" != "main" && "$BRANCH" != "develop" ]]; then
            echo "::error::Deployment is only allowed from 'main' or 'develop' branches. Current branch: $BRANCH"
            exit 1
          fi

      - name: Validate branch for prd deployment
        if: github.event_name == 'workflow_dispatch' && inputs.environment == 'prd'
        run: |
          BRANCH="${{ github.ref_name }}"
          if [[ "$BRANCH" != "main" ]]; then
            echo "::error::Production deployment is only allowed from 'main' branch. Current branch: $BRANCH"
            exit 1
          fi

      - name: Summary
        run: echo "Deploying to ${{ github.event_name == 'push' && 'dev' || inputs.environment }}"

  # =============================================================================
  # Deploy Frontend - Parameterized by environment
  # Dependency: ci -> setup -> deploy-frontend
  # =============================================================================
  deploy-frontend:
    name: Deploy Frontend (${{ needs.setup.outputs.environment }})
    needs: setup
    if: needs.setup.outputs.deploy_frontend == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.setup.outputs.environment }}
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Build frontend
        run: bun run build:web
        env:
          VITE_API_URL: ${{ vars.API_URL }}
          VITE_AUTH_TOKEN: ${{ secrets.AUTH_TOKEN }}
          VITE_TIMEZONE: ${{ vars.TIMEZONE || 'Asia/Tokyo' }}

      - name: Deploy frontend to S3
        run: |
          echo "Deploying to S3 bucket: ${{ vars.S3_BUCKET_NAME }}"

          # Deploy static assets with long cache
          aws s3 sync apps/web/dist/ s3://${{ vars.S3_BUCKET_NAME }}/ \
            --delete \
            --cache-control "public, max-age=31536000, immutable" \
            --exclude "index.html" \
            --exclude "*.json"

          # Deploy index.html with no-cache
          aws s3 cp apps/web/dist/index.html s3://${{ vars.S3_BUCKET_NAME }}/index.html \
            --cache-control "no-cache, no-store, must-revalidate"

          # Deploy JSON files with no-cache
          aws s3 sync apps/web/dist/ s3://${{ vars.S3_BUCKET_NAME }}/ \
            --exclude "*" \
            --include "*.json" \
            --cache-control "no-cache, no-store, must-revalidate"

      - name: Invalidate CloudFront cache
        run: |
          echo "Invalidating CloudFront distribution: ${{ vars.CLOUDFRONT_DISTRIBUTION_ID }}"
          aws cloudfront create-invalidation \
            --distribution-id ${{ vars.CLOUDFRONT_DISTRIBUTION_ID }} \
            --paths "/*"

      - name: Frontend deployment summary
        run: |
          echo "## Frontend Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ needs.setup.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **S3 Bucket**: ${{ vars.S3_BUCKET_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **CloudFront**: ${{ vars.CLOUDFRONT_DISTRIBUTION_ID }}" >> $GITHUB_STEP_SUMMARY

  # =============================================================================
  # DB Migration - Build migration image and run as ECS task
  # Dependency: ci -> setup -> db-migrate
  # =============================================================================
  db-migrate:
    name: DB Migration (${{ needs.setup.outputs.environment }})
    needs: setup
    if: needs.setup.outputs.deploy_backend == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.setup.outputs.environment }}
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push migration image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY_NAME }}
          IMAGE_TAG: migration-${{ github.sha }}
        run: |
          echo "Building migration image: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:migration \
            -f apps/api/src/lib/db/.image/Dockerfile \
            .

          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:migration

          echo "migration_image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Run database migration via ECS task
        id: run-migration
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY_NAME }}
        run: |
          echo "Running migration on cluster: ${{ vars.ECS_CLUSTER_NAME }}"
          echo "Using task definition: ${{ vars.ECS_MIGRATION_TASK_DEFINITION }}"

          TASK_ARN=$(aws ecs run-task \
            --cluster ${{ vars.ECS_CLUSTER_NAME }} \
            --task-definition ${{ vars.ECS_MIGRATION_TASK_DEFINITION }} \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=${{ vars.PRIVATE_SUBNET_IDS }},securityGroups=[${{ vars.ECS_SECURITY_GROUP_ID }}],assignPublicIp=DISABLED}" \
            --query 'tasks[0].taskArn' \
            --output text)

          echo "task_arn=$TASK_ARN" >> $GITHUB_OUTPUT
          echo "Migration task started: $TASK_ARN"

      - name: Wait for migration to complete
        run: |
          echo "Waiting for migration task to complete..."
          aws ecs wait tasks-stopped \
            --cluster ${{ vars.ECS_CLUSTER_NAME }} \
            --tasks ${{ steps.run-migration.outputs.task_arn }}

      - name: Check migration result
        run: |
          EXIT_CODE=$(aws ecs describe-tasks \
            --cluster ${{ vars.ECS_CLUSTER_NAME }} \
            --tasks ${{ steps.run-migration.outputs.task_arn }} \
            --query 'tasks[0].containers[0].exitCode' \
            --output text)

          if [ "$EXIT_CODE" != "0" ]; then
            echo "::error::Migration failed with exit code: $EXIT_CODE"
            REASON=$(aws ecs describe-tasks \
              --cluster ${{ vars.ECS_CLUSTER_NAME }} \
              --tasks ${{ steps.run-migration.outputs.task_arn }} \
              --query 'tasks[0].containers[0].reason' \
              --output text)
            echo "::error::Reason: $REASON"
            exit 1
          fi

          echo "Migration completed successfully"
          echo "## DB Migration Complete" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ needs.setup.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Task ARN**: ${{ steps.run-migration.outputs.task_arn }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Exit Code**: $EXIT_CODE" >> $GITHUB_STEP_SUMMARY

  # =============================================================================
  # Deploy Backend - Parameterized by environment
  # Dependency: ci -> setup -> db-migrate -> deploy-backend
  # =============================================================================
  deploy-backend:
    name: Deploy Backend (${{ needs.setup.outputs.environment }})
    needs: [setup, db-migrate]
    if: needs.setup.outputs.deploy_backend == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.setup.outputs.environment }}
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push API image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY_NAME }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "Building image: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:latest \
            -f apps/api/.image/Dockerfile \
            .

          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Update ECS service
        run: |
          echo "Updating ECS service: ${{ vars.ECS_SERVICE_NAME }}"
          aws ecs update-service \
            --cluster ${{ vars.ECS_CLUSTER_NAME }} \
            --service ${{ vars.ECS_SERVICE_NAME }} \
            --force-new-deployment

      - name: Wait for ECS deployment
        run: |
          echo "Waiting for ECS service to stabilize..."
          aws ecs wait services-stable \
            --cluster ${{ vars.ECS_CLUSTER_NAME }} \
            --services ${{ vars.ECS_SERVICE_NAME }}

      - name: Backend deployment summary
        run: |
          echo "## Backend Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ needs.setup.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **ECS Cluster**: ${{ vars.ECS_CLUSTER_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **ECS Service**: ${{ vars.ECS_SERVICE_NAME }}" >> $GITHUB_STEP_SUMMARY
